<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drag‑to‑Category Study</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --ink: #0f172a;
      --muted: #64748b;
      --brand: #4f46e5;
      --ok: #10b981;
      --warn: #f59e0b;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body { margin:0; background: var(--bg); color: var(--ink); font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    header { position: sticky; top:0; z-index: 10; background: rgba(255,255,255,0.85); backdrop-filter: blur(6px); border-bottom: 1px solid var(--border); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 12px 16px; }
    h1 { font-size: 20px; margin: 0; }
    .controls { display: flex; gap: 8px; margin-left: auto; }
    button { border: 0; padding: 8px 12px; border-radius: 10px; color: white; background: var(--ink); cursor: pointer; box-shadow: 0 1px 2px rgba(16,24,40,.04); }
    button:hover { filter: brightness(0.95); }
    .btn-primary { background: var(--brand); }
    .btn-ok { background: var(--ok); }
    .btn-warn { background: var(--warn); }

    main { max-width: 1100px; margin: 0 auto; padding: 16px; display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 900px){ main { grid-template-columns: 2fr 3fr; } }

    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; padding: 12px; }
    .panel h2 { margin: 0 0 8px; font-size: 18px; }

    .bank, .category { min-height: 96px; border: 1px solid var(--border); border-radius: 12px; background: #fff; padding: 10px; }
    .bank.over, .category.over { outline: 3px solid #c7d2fe; border-color: var(--brand); background: #eef2ff; }

    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: #fff; margin: 4px; font-size: 14px; cursor: grab; user-select: none; box-shadow: 0 1px 2px rgba(16,24,40,.04); }
    .chip.locked { opacity: .75; cursor: default; }
    .chip.ghost { border-style: dashed; color: var(--muted); background: #fafafa; }

    .cats { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 600px){ .cats { grid-template-columns: 1fr 1fr; } }

    .cat-card { background:#fff; border: 1px solid var(--border); border-radius: 14px; overflow: hidden; }
    .cat-head { display:flex; align-items:center; justify-content:space-between; padding: 8px 10px; border-bottom: 1px solid var(--border); font-weight: 600; }
    .cat-count { font-weight: 500; font-size: 12px; color: var(--muted); }

    .row { display: flex; gap: 12px; align-items: center; }
    .spacer { flex: 1; }

    textarea { width: 100%; height: 180px; border-radius: 12px; border: 1px solid var(--border); padding: 10px; resize: vertical; }
    .hint { color: var(--muted); font-size: 13px; }
    .small { color: var(--muted); font-size: 14px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap row">
      <h1>Drag‑to‑Category Study</h1>
      <div class="spacer"></div>
      <div class="controls">
        <button class="btn-primary" id="btnCheck">Check</button>
        <button id="btnToggleAns">Show Answers</button>
        <button class="btn-warn" id="btnUnlock">Unlock All</button>
        <button id="btnReset">Reset & Shuffle</button>
      </div>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2>Items</h2>
      <div id="bank" class="bank" aria-label="Item bank"></div>
      <p class="small">Drag items into the correct category boxes. Click <b>Check</b> to lock correct items; wrong ones return here.</p>
    </section>

    <section class="panel">
      <h2>Categories</h2>
      <div id="cats" class="cats"></div>
    </section>

    <section class="panel" style="grid-column: 1 / -1;">
      <h2>Dataset (whitespace‑indented)</h2>
      <textarea id="dataset"></textarea>
      <p class="hint">Deepest‑indented lines are <em>items</em>. Every ancestor level is a <em>category</em>. So items belong to <strong>all</strong> ancestor categories.</p>
    </section>
  </main>

  <script>
  // ===== Sample Data =====
  const defaultText = `Congenital heart defects
\tAcyanotic
\t\tIncreased pulmonary flow
\t\t\tAtrial Septal Defect
\t\t\tVentricular Septal Defect (most common acyanotic)
\t\t\tPatent ductus arteriosus
\t\tObstruction to blood flow from ventricles
\t\t\tCoarctation of aorta
\t\t\tAortic stenosis
\t\t\tPulmonic stenosis
\tCyanotic
\t\tDecreased pulmonary blood flow
\t\t\tTetralogy of fallot (most common cyanotic)
\t\t\t\tPulmonic stenosis
\t\t\t\tRight ventricular hypertrophy
\t\t\t\tOverriding aorta
\t\t\t\tVentricular septal defect
\t\t\tTricuspid atresia
\t\tMixed blood flow
\t\t\tTransposition of the great arteries
\t\t\tTotal anomalous pulmonary venous return
\t\t\tTruncus arteriosus
\t\t\tHypoplastic left heart syndrome`;

  // ===== State =====
  let leaves = [];           // {id,label}
  let categories = [];       // {id,label,node}
  let groups = {};           // catId -> [leafIds] (descendants at deepest depth)
  let bank = [];             // [leafId]
  let placed = {};           // catId -> [leafId]
  let locked = new Set();    // Set<leafId>
  let showAnswers = false;
  let seed = 1;

  // ===== Elements =====
  const elDataset = document.getElementById('dataset');
  const elBank = document.getElementById('bank');
  const elCats = document.getElementById('cats');
  const btnCheck = document.getElementById('btnCheck');
  const btnUnlock = document.getElementById('btnUnlock');
  const btnReset = document.getElementById('btnReset');
  const btnToggleAns = document.getElementById('btnToggleAns');

  elDataset.value = defaultText;

  // ===== Utils =====
  const slug = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
  let UID = 0;
  const uid = label => `${slug(label)}-${UID++}`;

  function rng() { // simple LCG based on seed
    let x = seed % 2147483647;
    return () => (x = x * 48271 % 2147483647) / 2147483647;
  }
  function shuffle(arr) {
    const r = rng();
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--) { const j = Math.floor(r()* (i+1)); [a[i],a[j]]=[a[j],a[i]]; }
    return a;
  }

  function countDepth(indent) {
    if (!indent) return 0;
    const tabs = (indent.match(/\t/g)||[]).length;
    const spaces = indent.replace(/\t/g,'').length;
    return tabs + Math.floor(spaces/2); // 2 spaces == 1 level
  }

  function parseIndented(text){
    const lines = text.split(/\r?\n/).map(l=>l.replace(/\s+$/,'')).filter(l=>l.trim().length>0);
    const items = lines.map(line=>{
      const m = /^([\t ]*)(.*)$/.exec(line);
      const indent = m[1]||''; const label=(m[2]||'').trim();
      return { depth: countDepth(indent), node: { label, children: [], _depth: 0, _parent: null, _leafId: null } };
    });
    const root = { label: items[0]?.node.label || 'Root', children: [], _depth: -1, _parent: null };
    const stack = [{ depth:-1, node: root }];
    for (const {depth,node} of items){
      while (stack.length && stack[stack.length-1].depth >= depth) stack.pop();
      const parent = stack[stack.length-1].node;
      node._depth = depth; node._parent = parent;
      if (depth===0 && root.children.length===0) root.label = node.label; else parent.children.push(node);
      stack.push({depth,node});
    }
    return {root};
  }

  function walk(node, fn){ fn(node); (node.children||[]).forEach(ch=>walk(ch,fn)); }

  function deepestDepth(root){
    let max = 0;
    walk(root, n => { if (n._depth>max) max=n._depth; });
    return max;
  }

  function collectDescendantLeafIds(node, targetDepth, cache = new Map()){
    if (cache.has(node)) return cache.get(node);
    let out = [];
    if (!node.children || node.children.length===0){
      // Only count as leaf if it is at targetDepth
      if (node._depth === targetDepth) out.push(node._leafId);
      cache.set(node, out);
      return out;
    }
    for (const ch of node.children){ out = out.concat(collectDescendantLeafIds(ch, targetDepth, cache)); }
    cache.set(node, out);
    return out;
  }

  function labelOf(id){ return (leaves.find(l=>l.id===id)||{}).label || id; }

  // ===== Render =====
  function renderBank(){
    elBank.innerHTML = '';
    elBank.classList.remove('over');
    bank.forEach(id=>{
      const div = document.createElement('div');
      div.className = 'chip';
      div.draggable = !locked.has(id);
      if (locked.has(id)) div.classList.add('locked');
      div.textContent = (locked.has(id)?'✅ ':'') + labelOf(id);
      div.dataset.id = id;
      div.addEventListener('dragstart', onDragStart);
      elBank.appendChild(div);
    });
  }

  function renderCats(){
    elCats.innerHTML = '';
    categories.forEach(cat=>{
      const card = document.createElement('div');
      card.className = 'cat-card';
      const head = document.createElement('div');
      head.className = 'cat-head';
      head.innerHTML = `<div>${cat.label}</div><div class="cat-count" id="count-${cat.id}"></div>`;
      const zone = document.createElement('div');
      zone.className = 'category';
      zone.dataset.catId = cat.id;
      zone.addEventListener('dragover', onZoneDragOver);
      zone.addEventListener('dragleave', onZoneDragLeave);
      zone.addEventListener('drop', onZoneDrop);

      // placed chips
      (placed[cat.id]||[]).forEach(id=> zone.appendChild(makeChip(id)) );

      // show missing as ghosts
      if (showAnswers){
        const answers = groups[cat.id] || [];
        const missing = answers.filter(id => !(placed[cat.id]||[]).includes(id));
        missing.forEach(id=>{
          const ghost = document.createElement('div');
          ghost.className = 'chip ghost';
          ghost.textContent = labelOf(id);
          zone.appendChild(ghost);
        });
      }

      const wrap = document.createElement('div');
      wrap.className = 'panel';
      wrap.style.border = 'none';
      wrap.style.padding = '10px';
      wrap.appendChild(zone);

      card.appendChild(head);
      card.appendChild(wrap);
      elCats.appendChild(card);

      updateCount(cat.id);
    });
  }

  function makeChip(id){
    const div = document.createElement('div');
    div.className = 'chip';
    div.draggable = !locked.has(id);
    if (locked.has(id)) div.classList.add('locked');
    div.textContent = (locked.has(id)?'✅ ':'') + labelOf(id);
    div.dataset.id = id;
    div.addEventListener('dragstart', onDragStart);
    return div;
  }

  function updateCount(catId){
    const total = (groups[catId]||[]).length;
    const correct = (placed[catId]||[]).filter(id => (groups[catId]||[]).includes(id)).length;
    const el = document.getElementById(`count-${catId}`);
    if (el) el.textContent = `${correct} / ${total}`;
  }

  // ===== Drag & Drop Handlers =====
  function onDragStart(e){
    e.dataTransfer.setData('text/plain', e.target.dataset.id);
    e.dataTransfer.effectAllowed = 'move';
  }

  function onZoneDragOver(e){ e.preventDefault(); e.currentTarget.classList.add('over'); }
  function onZoneDragLeave(e){ e.currentTarget.classList.remove('over'); }
  function onZoneDrop(e){
    e.preventDefault();
    e.currentTarget.classList.remove('over');
    const id = e.dataTransfer.getData('text/plain');
    if (!id || locked.has(id)) return;
    const catId = e.currentTarget.dataset.catId;
    // remove from bank
    bank = bank.filter(x=>x!==id);
    // remove from other categories
    for (const k of Object.keys(placed)) placed[k] = placed[k].filter(x=>x!==id);
    // add here
    placed[catId] = (placed[catId]||[]).concat(id);
    renderBank();
    renderCats();
  }

  // allow dropping back to bank
  elBank.addEventListener('dragover', e=>{ e.preventDefault(); elBank.classList.add('over'); });
  elBank.addEventListener('dragleave', ()=> elBank.classList.remove('over'));
  elBank.addEventListener('drop', e=>{
    e.preventDefault(); elBank.classList.remove('over');
    const id = e.dataTransfer.getData('text/plain');
    if (!id || locked.has(id)) return;
    // remove from all categories
    for (const k of Object.keys(placed)) placed[k] = placed[k].filter(x=>x!==id);
    if (!bank.includes(id)) bank.push(id);
    renderBank();
    renderCats();
  });

  // ===== Buttons =====
  btnCheck.addEventListener('click', ()=>{
    const wrong = [];
    // lock correct placements for each category independently
    for (const [catId, ids] of Object.entries(placed)){
      ids.forEach(id=>{
        if ((groups[catId]||[]).includes(id)) locked.add(id); else wrong.push(id);
      });
    }
    // snap wrong back
    for (const id of wrong){
      for (const k of Object.keys(placed)) placed[k] = placed[k].filter(x=>x!==id);
      if (!bank.includes(id)) bank.push(id);
    }
    renderBank();
    renderCats();
  });

  btnUnlock.addEventListener('click', ()=>{ locked = new Set(); renderBank(); renderCats(); });
  btnReset.addEventListener('click', ()=>{ seed++; initFromText(elDataset.value); });
  btnToggleAns.addEventListener('click', ()=>{ showAnswers = !showAnswers; btnToggleAns.textContent = showAnswers? 'Hide Answers':'Show Answers'; renderCats(); });

  // Re-parse on dataset change (debounced)
  let t;
  elDataset.addEventListener('input', ()=>{ clearTimeout(t); t=setTimeout(()=>initFromText(elDataset.value), 150); });

  // ===== Init =====
  function initFromText(text){
    UID = 0; locked = new Set(); showAnswers = false; btnToggleAns.textContent = 'Show Answers';

    // Parse into a tree with depth & parent links
    const { root } = parseIndented(text);

    // Determine deepest indentation level (items live here)
    const maxD = deepestDepth(root);

    // Clear collections
    leaves = []; groups = {}; placed = {}; bank = []; categories = [];

    // Assign ids to deepest nodes (items)
    walk(root, node => {
      if (node._depth === maxD && (!node.children || node.children.length === 0)){
        node._leafId = uid(node.label);
        leaves.push({ id: node._leafId, label: node.label });
      }
    });

    // For every node above deepest level, treat as a category whose correct set is all descendant deepest leaves
    walk(root, node => {
      if (node._depth >= 0 && node._depth < maxD){
        const catId = slug(node.label);
        const descendantLeafIds = collectDescendantLeafIds(node, maxD);
        if (descendantLeafIds.length > 0){
          categories.push({ id: catId, label: node.label, node });
          groups[catId] = descendantLeafIds.slice();
        }
      }
    });

    // Randomize bank of all items
    bank = shuffle(leaves.map(l=>l.id));

    renderBank();
    renderCats();
  }

  initFromText(defaultText);
  </script>
</body>
</html>
